#!/usr/bin/env python3

"""Usage:   tester (hr|lr) --input=input --output=output --model=model
            tester --help | -help | -h

Process input to create super resolution using the model input and plot it.
Arguments:
  input       a directory with input files
  output      a directory for saving the output images
  model       a .pt file to use for the model
Options:
  -h --help -h
"""
import os
from pathlib import Path

import torch

from dataset import SrDataset
from docopt import docopt

import numpy as np
import matplotlib.pyplot as plt
from unet import UNET
from tqdm import tqdm

from PIL import Image, ImageFont, ImageDraw

def writetext(imgfile, e_sr, e_lr):
    img = Image.open(imgfile)
    width, height = img.size
    draw = ImageDraw.Draw(img)
    font = ImageFont.truetype('./font/dancing.ttf', 20) 
    draw.text((width/2,0), "HR", font=font)
    draw.text((0,width/2), "Error", font=font)

    draw.text((0,0), "SR", font=font)
    draw.text((32,0), "L1="+str(e_sr), font=font, fill=(255,0,0))

    draw.text((height/2,width/2), "LR", font=font, fill=(255,255,255))
    draw.text((height/2+32,width/2), "L1="+str(e_lr), font=font, fill=(255,0,0))

    img.save("/tmp/test.png")
    os.system("mv /tmp/test.png " + imgfile)

def evaluate(args):
    """

    Parameters
    ----------
    args: the docopt arguments passed

    Returns
    -------

    """
    parameters = {"batch_size": 1, "shuffle": False, "num_workers": 6}

    use_cuda = torch.cuda.is_available()
    device = torch.device("cuda:0" if use_cuda else "cpu")
    torch.backends.cudnn.benchmark = True

    test_set = SrDataset(args["--input"], test=True, hr=True)
    test_generator = torch.utils.data.DataLoader(test_set, **parameters)

    # model create and load
    unet = UNET(in_channels=1, out_channels=1, init_features=32)
    unet.to(device)
    test_loss = 0
    unet.load_state_dict(torch.load(args["--model"]))
    with torch.no_grad():
        for batch_idx, data in tqdm(enumerate(test_generator), total = len(test_set.datalist)):
            unet.eval()
            # unet.train(False)
            x_test = data["lr"]
            y_test = data["hr"]
            stat_test = data["stats"]
            x_test = x_test.to(device)
            y_test = y_test.numpy()
            y_pred = unet(x_test)

            # Inverse of the nomalizations used. Applied on SR data
            stat_test["std"] = stat_test["std"].numpy()
            stat_test["mean"] = stat_test["mean"].numpy()
            y_pred = y_pred.cpu().numpy()
            y_pred = (y_pred * stat_test["std"]) + stat_test["mean"]
            image_sign = np.sign(y_pred)
            y_pred = image_sign * (np.exp(np.abs(y_pred)) - 1.0)

            # Compute the loss if HR is given
            if args["hr"]:
                loss_test = np.mean(np.abs(y_pred - y_test))
                sr_hr = np.hstack([y_pred.reshape(256, 256), y_test.reshape(256, 256)])

            # Inverse normalize the LR image
            x_test = x_test.cpu().numpy()
            x_test = (x_test * stat_test["std"]) + stat_test["mean"]
            image_sign = np.sign(x_test)
            x_test = image_sign * (np.exp(np.abs(x_test)) - 1.0)

            # Create and save image consisting of error map, HR, SR, LR
            if args["hr"]:
                error = np.abs(y_pred - y_test).reshape(256, 256)
                error = error * (255 / np.max(error))
                lr_error = np.hstack([error, x_test.reshape(256, 256)])
                save_plots = np.vstack([sr_hr, lr_error])
            else:
                save_plots = np.vstack(
                    [y_pred.reshape(256, 256), x_test.reshape(256, 256)]
                )
            filename = os.path.join(args["--output"], f"{batch_idx}.png")
            m = np.mean(save_plots)
            s = np.std(save_plots)
            plt.imsave(filename, save_plots, cmap="gray", vmin = m-3*s , vmax = m+3*s )
            if args["hr"]:
                test_loss = test_loss + (loss_test)
                lrerror = np.mean(np.abs(y_test - x_test))
                srerror = np.mean(np.abs(y_test - y_pred))
                writetext(os.path.abspath(filename), srerror ,lrerror)

        if args["hr"]:
            print("\nTest Loss: {:.6f}".format(test_loss / len(test_generator)))


if __name__ == "__main__":
    args = docopt(__doc__)
    for a in ["--input", "--output", "--model"]:
        args[a] = Path(args[a]).resolve()
    print("Input being read from:", args["--input"])
    #print(args)
    evaluate(args)
    """ An example:
     ./tester hr --input input.npz --output output.npz --model srunet.pt
    {'--help': False,
     '--input': True,
     '--model': True,
     '--output': True,
     '-e': False,
     '-l': False,
     '-p': False,
     'input': 'input_dir',
     'model': 'srunet.pt',
     'output': 'output_dir',
     'hr': True,
     'lr': False}
    """
